#!/usr/bin/env ruby
require 'uri'
require 'optparse'

# resolves a URI into a hash
def resolve_url(url)
  parsed = Hash.new

  uri = URI.parse(url)
  parsed[:database] = uri.path[1..-1]
  parsed[:host] = uri.host
  parsed[:port] = uri.port ? uri.port : 5432
  parsed[:user] = uri.user
  parsed[:user_cli] = uri.user ? "-U #{uri.user}" : ""
  parsed[:password] = uri.password
  parsed[:url] = url
  return parsed
end

$_writeColors = {"default" => "38","black" => "30","red" => "31","green" => "32","brown" => "33", "blue" => "34", "purple" => "35",
 "cyan" => "36", "gray" => "37", "dark gray" => "1;30", "light red" => "1;31", "light green" => "1;32", "yellow" => "1;33",
  "light blue" => "1;34", "light purple" => "1;35", "light cyan" => "1;36", "white" => "1;37"}
$_writeBgColors = {"default" => "0", "black" => "40", "red" => "41", "green" => "42", "brown" => "43", "blue" => "44",
 "purple" => "45", "cyan" => "46", "gray" => "47", "dark gray" => "100", "light red" => "101", "light green" => "102",
 "yellow" => "103", "light blue" => "104", "light purple" => "105", "light cyan" => "106", "white" => "107"}
def colorize(text, color = "default", bgColor = "default")
  color_code = $_writeColors[color]
  bgColor_code = $_writeBgColors[bgColor]
  return "\033[#{bgColor_code};#{color_code}m#{text}\033[0m"
end
def write(text, color = "default", bgColor = "default")
  puts colorize(text, color, bgColor);
end

$options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: {Source} {Destination} [options]"

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    $options[:verbose] = v
  end

  opts.on("-s", "--[no-]skip", "Skip confirmation prompts") do |v|
    $options[:skip] = v
  end

  opts.on("-b", "--backup [file]", "Save a backup of the destination database") do |v|
    $options[:backup] = v
  end

  opts.on("-e", "--expire-file [file]", "File to read which table to expire") do |v|
    path = File.expand_path(v, __dir__)
    $options[:expire] = Array.new
    if File.file?(path) then
      file = File.new(path, "r")
      while (line = file.gets)
        parts = line.chomp.split(':')
        data = {
          table: parts[0],
          column: parts[1] || 'expiry_date',
          interval: parts[2] || '3 months'
        }
        $options[:expire].push(data)
      end
    end
  end

  opts.on("-I", "--ignore-file [file]", "File to read with tables to ignore") do |v|
    path = File.expand_path(v, __dir__)
    $options[:ignore] = Array.new
    if File.file?(path) then
      file = File.new(path, "r")
      while (line = file.gets)
        $options[:ignore].push(line.chomp)
      end
    else
      write("Exclude file not found (#{path})", "red")
    end
  end

  opts.on("-i", "--ignore [list]", Array, "Comma seperated list of tables to ignore") do |v|
    $options[:ignore] = v
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

if (ARGV.length < 2)
  puts "No source/destination sepecified. Exiting."
  exit
end

$from = resolve_url(ARGV[0])
$to = resolve_url(ARGV[1])

$extensions = []
$backupFile = $options[:backup] ? $options[:backup] : './tmp_copy_psql.backup'
$verboseToggle = $options[:verbose] ? '--verbose' : ''
$quietToggle = $options[:verbose] ? '--echo-queries' : '--quiet'
$tableOnly = $options[:backup] ? '' : $options[:ignore] ? $options[:ignore].map { |table| "--table=#{table}"}.join(" ") : nil
$excludeTable = $options[:backup] ? '' : $options[:ignore] ? $options[:ignore].map { |table| "--exclude-table=#{table}"}.join(" ") : nil
$hasTable = $tableOnly && $tableOnly.length > 0

def backupDatabase()
  if $options[:backup] then
    puts "- Backing up database #{$from[:database]}..."
  elsif $hasTable
    puts "- Backing up tables..."
  end

  if $options[:backup] || $hasTable then
    %x( env PGPASSWORD=#{$to[:password]} pg_dump -c -o -w -h #{$to[:host]} #{$to[:user_cli]} -p #{$to[:port]} --file="#{$backupFile}" #{$tableOnly} --schema=public --format=c --no-owner --no-acl #{$verboseToggle} #{$to[:database]} )
  end
end

def backupExtensions()
  puts "- Backing up extensions..."
  $extensions = %x( psql #{$from[:url]} -w -X -A -t #{$quietToggle} --command="SELECT extname, extversion FROM pg_extension;")
  $extensions = $extensions.split("\n").map{ |x| x.split("|").map{ |y| y.strip! || y }}
end

def recreateSchema()
  puts "- Recreating public schema..."
  %x( psql #{$to[:url]} -w -X #{$quietToggle} --command="DROP SCHEMA IF EXISTS public CASCADE; CREATE SCHEMA public AUTHORIZATION #{$to[:user]};" )
end

def restoreDatabase()
  if ($options[:backup] || $hasTable) && File.exists?($backupFile) then
    puts "- Restoring tables..."
    %x( env PGPASSWORD=#{$to[:password]} pg_restore -c -w -h #{$to[:host]} #{$to[:user_cli]} -p #{$to[:port]} -d #{$to[:database]} #{$tableOnly} --schema=public --no-acl --no-owner #{$verboseToggle} "#{$backupFile}" )

    if !$options[:backup]
      File.delete($backupFile)
    end
  end
end

def copyDatabase()
  puts "- Copying database..."
  %x( env PGPASSWORD=#{$from[:password]} pg_dump -o -w -h #{$from[:host]} #{$from[:user_cli]} -p #{$from[:port]} #{$excludeTable} --schema=public --format=c #{$verboseToggle} #{$from[:database]} | env PGPASSWORD=#{$to[:password]} pg_restore -w #{$to[:user_cli]} -h #{$to[:host]} -d #{$to[:database]} -p #{$to[:port]} --no-acl --no-owner #{$verboseToggle} )
end

def restoreExtensions()
  puts "- Restoring extensions..."
  $extensions.each do |ext|
    if $options[:verbose]
      puts "  - #{ext[0]}"
    end
    %x( psql #{$to[:url]} -w -X #{$quietToggle} --command="CREATE EXTENSION IF NOT EXISTS \\"#{ext[0]}\\" WITH SCHEMA public;" )
  end
end

def expire()
  if $options[:expire] && $options[:expire].length
    puts "- Expiring old rows..."

    $options[:expire].each do |expiry|
      if $options[:verbose]
        puts "  - #{expiry[:table]} (#{expiry[:interval]})"
      end
      %x( psql #{$to[:url]} -w -X #{$quietToggle} --command="DELETE FROM #{expiry[:table]} WHERE #{expiry[:column]} < current_timestamp - interval '#{expiry[:interval]}'" )
    end
  end
end

def execute()
  backupExtensions()
  backupDatabase()
  recreateSchema()
  restoreExtensions()
  restoreDatabase()
  copyDatabase()
  expire()
  exit
end

write("Copying database:", "green")
write(" Source:", "blue")
puts "  Host: #{$from[:host]}:#{$from[:port]}"
puts "  DB:   #{$from[:database]}"
puts "  User: #{$from[:user]}"
write(" Destination:", "red")
puts "  Host: #{$to[:host]}:#{$to[:port]}"
puts "  DB:   #{$to[:database]}"
puts "  User: #{$to[:user]}"

if $options[:ignore]
  write(" Ignoring Tables:", "yellow")
  $options[:ignore].each do |ignore|
    puts "  #{ignore}"
  end
end

puts ""

if $options[:backup]
  write(" Backup File:", "green")
  puts "  #{$backupFile}"
else
  write("---- !WARNING! No backup will be created ----", "white", "red")
end

write("---- !WARNING! Destination database \"#{$to[:database]}\" will be dropped. ----", "white", "red")

if $options[:skip] then
  execute()
else
  puts ""
  print "Enter the destination database name to confirm: "

  name = STDIN.gets.chomp.downcase
  if name == $to[:database].downcase
    execute()
  else
    puts "Names do not match. Exiting."
    exit
  end
end
